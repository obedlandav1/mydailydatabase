package com.conetdev.mydailydatabase.api.v1;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.logging.Level;
import java.util.logging.Logger;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import com.conetdev.mydailydatabase.model.Usuario;
import com.conetdev.mydailydatabase.repository.UsuarioRepository;
import com.conetdev.mydailydatabase.service.UsuarioService;
import com.conetdev.mydailydatabase.utils.PasswordUtils;

@CrossOrigin(origins = "http://localhost:8080")
@RestController
@RequestMapping("/api/v1")
public class UserController {

    @Autowired
    UsuarioRepository userRepository;

    @Autowired
    UsuarioService usuarioService;

    @Autowired
    PasswordUtils passutil;

    private String class_name = UserController.class.getName();

    @GetMapping("/usuario")
    public ResponseEntity<List<Usuario>> getAll(@RequestParam(required = false) Long id) {
        try {
            List<Usuario> lista = new ArrayList<Usuario>();
            userRepository.findAll().forEach(lista::add);
            if (lista.isEmpty()) {
                Logger.getLogger(class_name).log(Level.INFO,
                        "HttpStatus: OK, List of users is empty");
                return new ResponseEntity<>(HttpStatus.NO_CONTENT);
            }

            Logger.getLogger(class_name).log(Level.INFO, "HtpStatus: OK, List of users returned");
            return new ResponseEntity<>(lista, HttpStatus.OK);
        } catch (Exception e) {
            Logger.getLogger(class_name).log(Level.SEVERE,
                    "HttpStatus: INTERNAL_SERVER_ERROR, Error on server processing", e.toString());
            return new ResponseEntity<>(null, HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    @GetMapping("/usuario/{id}")
    public ResponseEntity<Usuario> getById(@PathVariable("id") Long id) {
        try {
            Optional<Usuario> entidad = userRepository.findById(id);
            if (entidad.isPresent()) {
                return new ResponseEntity<>(entidad.get(), HttpStatus.OK);
            } else {
                return new ResponseEntity<>(HttpStatus.NOT_FOUND);
            }
        } catch (Exception e) {
            Logger.getLogger(class_name).log(Level.SEVERE, "Error on getById()", e.toString());
            return new ResponseEntity<>(HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    @PostMapping("/usuario")
    public ResponseEntity<Usuario> create(@RequestBody Usuario entidad) {
        try {
            Usuario user = new Usuario();
            user.setTipoIdentidad(entidad.getTipoIdentidad());
            user.setNombreUsuario(entidad.getNombreUsuario());
            user.setApellidoUsuario(entidad.getApellidoUsuario());
            user.setIdentidadUsuario(entidad.getIdentidadUsuario());
            user.setCelularUsuario(entidad.getCelularUsuario());
            user.setPasswordUsuario(passutil.hash(entidad.getPasswordUsuario()));
            user.setEstado(entidad.getEstado());
            user.setRoles(entidad.getRoles());
            // user.setRazonesSociales(entidad.getRazonesSociales());
            Usuario _entidad = userRepository.save(user);
            return new ResponseEntity<>(_entidad, HttpStatus.CREATED);
        } catch (Exception e) {
            Logger.getLogger(class_name).log(Level.SEVERE, "Error on create()", e.toString());
            return new ResponseEntity<>(null, HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    @PutMapping("/usuario/{id}")
    public ResponseEntity<Usuario> update(@PathVariable("id") Long id, @RequestBody Usuario entidad) {
        try {
            Usuario _entidad = userRepository.findById(id).orElse(null);
            if (_entidad != null) {
                _entidad.setTipoIdentidad(entidad.getTipoIdentidad());
                _entidad.setNombreUsuario(entidad.getNombreUsuario());
                _entidad.setApellidoUsuario(entidad.getApellidoUsuario());
                _entidad.setIdentidadUsuario(entidad.getIdentidadUsuario());
                _entidad.setCelularUsuario(entidad.getCelularUsuario());
                _entidad.setEstado(entidad.getEstado());
                _entidad.setRoles(entidad.getRoles());
                // _entidad.setRazonesSociales(entidad.getRazonesSociales());
                _entidad.setEstado(entidad.getEstado());
                return new ResponseEntity<>(userRepository.save(_entidad), HttpStatus.OK);
            } else {
                return new ResponseEntity<>(HttpStatus.NOT_FOUND);
            }
        } catch (Exception e) {
            Logger.getLogger(class_name).log(Level.SEVERE, "Error on update(): ", e.toString());
            return new ResponseEntity<>(null, HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    @DeleteMapping("/usuario/{id}")
    public ResponseEntity<HttpStatus> delete(@PathVariable("id") Long id) {
        try {
            userRepository.deleteById(id);
            return new ResponseEntity<>(HttpStatus.NO_CONTENT);
        } catch (Exception e) {
            Logger.getLogger(class_name).log(Level.SEVERE, "Error on delete(): ", e.toString());
            return new ResponseEntity<>(HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    @PutMapping("/usuario/password/{id}")
    public ResponseEntity<HttpStatus> updatePassword(@PathVariable("id") Long id,
            @RequestBody Map<String, String> request) {
        try {
            String current = request.get("currentPassword");
            String newpass = request.get("newPassword");

            Usuario user = userRepository.findById(id).orElse(null);
            if (user == null) {
                return new ResponseEntity<>(HttpStatus.NOT_FOUND);
            }

            if (!passutil.matches(current, user.getPasswordUsuario())) {
                return new ResponseEntity<>(HttpStatus.UNAUTHORIZED); // Or BAD_REQUEST
            }

            user.setPasswordUsuario(passutil.hash(newpass));
            userRepository.save(user);
            return new ResponseEntity<>(HttpStatus.OK);
        } catch (Exception e) {
            Logger.getLogger(class_name).log(Level.SEVERE, "Error on updatePassword(): ",
                    e.toString());
            return new ResponseEntity<>(HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

}


package com.conetdev.mydailydatabase.mapper;

import com.conetdev.mydailydatabase.dto.UsuarioDto;
import com.conetdev.mydailydatabase.model.Usuario;
import com.conetdev.mydailydatabase.response.UsuarioResponse;
import com.conetdev.mydailydatabase.model.TipoRol;
import com.conetdev.mydailydatabase.model.TipoIdentidad;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.Named;
import org.mapstruct.factory.Mappers;

@Mapper(componentModel = "spring")
public interface UsuarioMapper {

    UsuarioMapper INSTANCE = Mappers.getMapper(UsuarioMapper.class);

    @Mapping(source = "id", target = "id")
    @Mapping(source = "nombreUsuario", target = "nombre")
    @Mapping(source = "apellidoUsuario", target = "apellido")
    @Mapping(source = "identidadUsuario", target = "identidad")
    @Mapping(source = "celularUsuario", target = "celular")
    @Mapping(source = "estado", target = "estado")
    // @Mapping(source = "estado", target = "estado", qualifiedByName = "mapEstado")

    UsuarioResponse toUsuarioResponse(Usuario usuario);

    // Mapeo automático para los Sub-DTOs (MapStruct detectará los nombres iguales
    // id/nombreLargo)
    UsuarioDto.RoleDto toUsuarioResponseRole(TipoRol rol);

    UsuarioDto.TipoIdentidadDto toUsuarioResponseTipoIdentidad(TipoIdentidad tipo);

    // Mapping from DTO to Entity
    @Mapping(source = "id", target = "id")
    @Mapping(source = "nombre", target = "nombreUsuario")
    @Mapping(source = "apellido", target = "apellidoUsuario")
    @Mapping(source = "identidad", target = "identidadUsuario")
    @Mapping(source = "celular", target = "celularUsuario")
    @Mapping(source = "estado", target = "estado")
    @Mapping(source = "roles", target = "roles")
    @Mapping(source = "tipoIdentidad", target = "tipoIdentidad")

    Usuario toUsuarioEntity(UsuarioDto dto);

    // Helper mappings for nested objects
    TipoRol toTipoRol(UsuarioDto.RoleDto roleDto);

    TipoIdentidad toTipoIdentidad(UsuarioDto.TipoIdentidadDto tipoIdentidadDto);

    // @Named("mapEstado")
    // default String mapEstado(Integer estado) {
    // switch (estado) {
    // case 1:
    // return "ACTIVO";
    // case 2:
    // return "INACTIVO";
    // default:
    // return "DESCONOCIDO";
    // }
    // }
}



    @Override
    public ResponseEntity<HttpStatus> updateById(Long id, UsuarioUpdate dto) {
        Usuario usuario = usuarioRepository.findById(id).orElse(null);

        if (usuario == null) {
            return new ResponseEntity<>(HttpStatus.NOT_FOUND);
        }

        // Utilizamos el mapper para copiar todos los campos del DTO al entidad
        // existente
        UsuarioMapper.INSTANCE.toUsuarioEntity(dto, usuario);

        // Persistimos los cambios
        usuarioRepository.save(usuario);

        Logger.getLogger(class_name).log(Level.INFO,
                "HttpStatus: OK, User updated");

        return new ResponseEntity<>(HttpStatus.OK);
    }


    @Override
    public ResponseEntity<HttpStatus> updateById(Long id, UsuarioUpdate dto) {
        Usuario usuario = usuarioRepository.findById(id).orElse(null);

        if (usuario == null) {
            return new ResponseEntity<>(HttpStatus.NOT_FOUND);
        }


        usuario.setNombreUsuario(dto.getNombre());
        usuario.setApellidoUsuario(dto.getApellido());
        usuario.setIdentidadUsuario(dto.getIdentidad());
        usuario.setCelularUsuario(dto.getCelular());
        usuario.setEstado(dto.getEstado());

        // Convert RoleDto Set to List<TipoRol>
        List<TipoRol> roleEntities = dto.getRoles()
                .stream()
                .map(UsuarioMapper.INSTANCE::toTipoRol)
                .collect(Collectors.toList());
        usuario.setRoles(roleEntities);

        // Convert TipoIdentidadDto to TipoIdentidad entity
        TipoIdentidad tipoIdentidadEntity = UsuarioMapper.INSTANCE
                .toTipoIdentidad(dto.getTipoIdentidad());
        usuario.setTipoIdentidad(tipoIdentidadEntity);
        // Persistimos los cambios
        usuarioRepository.save(usuario);

        Logger.getLogger(class_name).log(Level.INFO,
                "HttpStatus: OK, User updated");

        return new ResponseEntity<>(HttpStatus.OK);
    }


